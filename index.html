<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
  <title>花火テトリス</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
      font-family: Arial, sans-serif;
      width: 100vw; min-height: 100svh; height: 100vh;
      overflow-x: hidden;
    }
    body {
      width: 100vw; min-height: 100svh; display: flex;
      flex-direction: column; align-items: center; justify-content: flex-start;
    }
    .game-outer {
      display: flex; flex-direction: column; align-items: center;
      width: 100vw; max-width: 100vw; padding-bottom: 0;
    }
    .game-container {
      display: flex; margin-top: 10px; gap: 10px;
      background: rgba(0,0,0,0.32); box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      border-radius: 12px; max-width: 97vw;
    }
    @media (max-width: 768px) {
      .game-container {
        flex-direction: column; align-items: center; gap: 5px; padding: 0;
        border-radius: 0; margin: 0; width: 100vw; max-width: 100vw;
      }
      .game-outer { padding-bottom: 0; width: 100vw; }
    }
    .game-board {
      position: relative;
      background: linear-gradient(135deg, #151728 90%, #111a22 100%);
      margin: 0 auto; box-sizing: border-box;
      border: 3px solid #35e0ff;
      border-radius: 12px;
      box-shadow: 0 0 0 8px #0b253a, 0 0 15px 3px #3cf0ff3c inset;
    }
    @media (max-width: 768px) {
      .game-board { margin: 0 auto; width: 100vw; max-width: 100vw;}
    }
    canvas {
      display: block; margin: 0 auto; background: #131e35;
      border-radius: 4px; box-sizing: border-box; touch-action: none;
    }
    .game-over {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.96); color: white; padding: 32px 22px 22px 22px;
      border-radius: 15px; text-align: center;
      border: 3px solid #e74c3c; display: none; z-index: 40;
    }
    .game-over h2 {
      margin: 0 0 15px 0; color: #e74c3c; font-size: 1.5em;
      letter-spacing: 0.12em;
    }
    .game-over button {
      background: #4a90e2; color: white; border: none;
      padding: 11px 26px; border-radius: 5px; cursor: pointer;
      font-size: 18px; margin-top: 15px;
    }
    .game-over button:hover { background: #357abd; }
    .info-panel {
      color: white; display: flex; flex-direction: column; gap: 13px;
      min-width: 135px; user-select: none;
    }
    @media (max-width: 768px) { .info-panel { display: none; } }
    .info-box {
      background: rgba(0,0,0,0.52); padding: 12px 7px;
      border-radius: 10px; border: 2px solid #4a90e2;
    }
    .info-box h3 {
      margin: 0 0 10px 0; color: #4a90e2; text-align: center;
      font-size: 1em; letter-spacing: 0.06em;
    }
    .info-box p {
      margin: 4px 0; font-size: 18px; text-align: center;
    }
    .controls { font-size: 12.7px; line-height: 1.44; }
    .next-piece { display: flex; justify-content: center; align-items: center; height: 54px; }
    .mobile-header {
      display: none;
    }
    @media (max-width: 768px) {
      .mobile-header {
        display: flex; justify-content: space-between; width: 100%; max-width: 300px;
        background: rgba(0,0,0,0.5); padding: 7px 13px; border-radius: 11px;
        border: 2px solid #4a90e2; color: white; font-size: 15px; margin-bottom: 5px;
      }
      .mobile-header .stat { display: flex; flex-direction: column; align-items: center; flex: 1; }
      .mobile-header .stat-label { font-size: 10.5px; color: #4a90e2; margin-bottom: 1px; }
      .mobile-header .stat-value { font-weight: bold; font-size: 16px; }
    }
    .touch-controls { display: none; }
    @media (max-width: 768px) {
      .touch-controls {
        position: fixed; left: 0; right: 0; bottom: 0; z-index: 100;
        display: grid; grid-template-columns: repeat(3, 1fr); gap: 11px;
        padding: 14px 9px 36px 9px;
        background: rgba(0, 0, 0, 0.78); border-top: 2px solid #4a90e2;
        margin: 0; min-height: 98px; width: 100vw; max-width: 100vw;
        box-sizing: border-box; padding-bottom: calc(30px + env(safe-area-inset-bottom,0px));
      }
    }
    .control-btn {
      background: rgba(74,144,226,0.82); color: white; border: none;
      border-radius: 12px; padding: 15px 7px; font-size: 21.5px;
      font-weight: bold; cursor: pointer; user-select: none;
      min-height: 52px; display: flex; align-items: center; justify-content: center;
      box-shadow: 0 3px 8px rgba(0,0,0,0.23); transition: all 0.2s; touch-action: manipulation;
    }
    .control-btn:active {
      background: rgba(74,144,226,1); transform: scale(0.93);
      box-shadow: 0 1.5px 3px rgba(0,0,0,0.34);
    }
    .control-btn.rotate { grid-column: 2; font-size: 32px; background: rgba(138,43,226,0.87);}
    .control-btn.rotate:active { background: rgba(138,43,226,1);}
    .control-btn.left { grid-column: 1; grid-row: 2;}
    .control-btn.down { grid-column: 2; grid-row: 2;}
    .control-btn.right { grid-column: 3; grid-row: 2;}
    .control-btn.drop {
      grid-column: 1/4; grid-row: 3;
      background: rgba(231,76,60,0.88); font-size: 19px; min-height: 50px; font-weight: 900;
    }
    .control-btn.drop:active { background: rgba(231,76,60,1);}
    .next-piece-mobile {
      display: none; position: absolute; top: 10px; right: 10px;
      background: rgba(0,0,0,0.88); padding: 7px; border-radius: 8px;
      border: 1px solid #4a90e2;
    }
    @media (max-width: 768px) {
      .next-piece-mobile { display: block; }
    }
  </style>
</head>
<body>
<div class="game-outer">
  <div class="mobile-header">
      <div class="stat">
          <div class="stat-label">スコア</div>
          <div class="stat-value" id="mobileScore">0</div>
      </div>
      <div class="stat">
          <div class="stat-label">レベル</div>
          <div class="stat-value" id="mobileLevel">1</div>
      </div>
      <div class="stat">
          <div class="stat-label">ライン</div>
          <div class="stat-value" id="mobileLines">0</div>
      </div>
  </div>
  <div class="game-container">
      <div class="game-board" id="boardFrame">
          <canvas id="gameCanvas"></canvas>
          <canvas id="effectsCanvas" style="position:absolute;top:0;left:0;pointer-events:none;"></canvas>
          <div class="next-piece-mobile">
              <canvas id="nextCanvasMobile" width="60" height="45"></canvas>
          </div>
          <div class="game-over" id="gameOver">
              <h2>ゲームオーバー</h2>
              <p>スコア: <span id="finalScore"></span></p>
              <p>レベル: <span id="finalLevel"></span></p>
              <button onclick="startGame()">もう一度プレイ</button>
          </div>
      </div>
      <div class="info-panel">
          <div class="info-box"><h3>スコア</h3><p id="score">0</p></div>
          <div class="info-box"><h3>レベル</h3><p id="level">1</p></div>
          <div class="info-box"><h3>ライン</h3><p id="lines">0</p></div>
          <div class="info-box"><h3>次のピース</h3>
              <div class="next-piece"><canvas id="nextCanvas" width="80" height="60"></canvas></div>
          </div>
          <div class="info-box controls">
              <h3>操作方法</h3>
              <p>←→: 移動</p>
              <p>↓: 高速落下</p>
              <p>↑: 回転</p>
              <p>スペース: ドロップ</p>
          </div>
      </div>
  </div>
  <div class="touch-controls">
      <button class="control-btn rotate" id="rotateBtn">↻</button>
      <button class="control-btn left" id="leftBtn">←</button>
      <button class="control-btn down" id="downBtn">↓</button>
      <button class="control-btn right" id="rightBtn">→</button>
      <button class="control-btn drop" id="dropBtn">DROP</button>
  </div>
</div>
<script>
const BOARD_WIDTH = 10, BOARD_HEIGHT = 20;
let BLOCK_SIZE = 30;

// Canvasコンテキストの定義
const nextCanvas = document.getElementById('nextCanvas');
const nextCtx = nextCanvas.getContext('2d');

const nextCanvasMobile = document.getElementById('nextCanvasMobile');
const nextCtxMobile = nextCanvasMobile.getContext('2d');


// サイズ調整と盤面ピタリ描画（黒帯ゼロ/必ず両端までピース）
function resizeCanvasForMobile() {
    const canvas = document.getElementById('gameCanvas');
    const effectsCanvas = document.getElementById('effectsCanvas');
    let isMobile = window.innerWidth <= 768;
    const touchPad = isMobile ? 120 : 0;
    // 縦横とも「ボーダー幅含め全く余らない」サイズを保証
    const padW = Math.floor(Math.min(window.innerWidth, 440, window.innerHeight * 0.56));
    let block = Math.floor(Math.min(
        (padW - 6) / BOARD_WIDTH, // 盤面の左右ぴったり（盤枠3pxずつ）
        ((window.innerHeight - touchPad - 38) - 6) / BOARD_HEIGHT
    ));
    block = Math.max(16, Math.min(block, 48));
    BLOCK_SIZE = block;

    const pxW = BOARD_WIDTH * BLOCK_SIZE;
    const pxH = BOARD_HEIGHT * BLOCK_SIZE;

    // ボーダー分もぴったり含めて盤面ジャスト設定
    [canvas, effectsCanvas].forEach(c => {
        c.width = pxW;
        c.height = pxH;
        c.style.width = pxW+"px";
        c.style.height = pxH+"px";
        c.style.maxWidth = "100vw";
        c.style.maxHeight = "90vh";
        c.style.display = "block";
        c.style.margin = c.style.padding = c.style.border = "0";
        c.parentNode.style.width = pxW + "px";
        c.parentNode.style.height = pxH + "px";
    });
}
window.addEventListener('resize', resizeCanvasForMobile);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvasForMobile, 400));

// 盤面の境界をcanvas上にも描画（見た目のエッジ強化）
function drawBoardFrame() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#35e0ff';
    ctx.strokeRect(0.5, 0.5, canvas.width-1, canvas.height-1);
    ctx.restore();
}

// 初期化のたびに必ず盤面リサイズ＆枠線描写
resizeCanvasForMobile();
drawBoardFrame();

const TETROMINOS = [
  { shape: [ [1,1,1,1] ], color: '#00f5ff' },
  { shape: [ [1,1],[1,1] ], color: '#ffff00' },
  { shape: [ [0,1,0],[1,1,1] ], color: '#800080' },
  { shape: [ [0,1,1],[1,1,0] ], color: '#00ff00' },
  { shape: [ [1,1,0],[0,1,1] ], color: '#ff0000' },
  { shape: [ [1,0,0],[1,1,1] ], color: '#ffa500' },
  { shape: [ [0,0,1],[1,1,1] ], color: '#0000ff' }
];

let board = [];
let currentPiece = null;
let nextPiece = null;
let score = 0, level = 1, lines = 0;
let dropTime = 0, dropInterval = 1000;
let gameRunning = true;
let particles = [];

// ========== パーティクル花火 ==========

class Particle {
  constructor(x, y, color) {
    this.x = x; this.y = y;
    this.vx = (Math.random()-0.5)*13;
    this.vy = (Math.random()-0.5)*13 - 5;
    this.color = color;
    this.life = 1.0;
    this.decay = Math.random()*0.02 + 0.012;
    this.size = Math.random()*4 + 2;
    this.g = 0.3;
    this.sparkle = Math.random()>0.7;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += this.g;
    this.vx *= 0.98;
    this.life -= this.decay;
  }
  draw(ctx) {
    if(this.life<=0) return;
    ctx.save();
    ctx.globalAlpha = this.life;
    if(this.sparkle){
      ctx.shadowColor = this.color; ctx.shadowBlur = 16;
    }
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size*this.life,0,Math.PI*2);
    ctx.fill();
    if(this.sparkle && this.life>0.5){
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(this.x,this.y,(this.size*this.life)*0.34,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }
  isDead() { return this.life<=0 || this.y > BOARD_HEIGHT*BLOCK_SIZE+24; }
}
function createFireworks(x, y, color, count=18) {
  for(let i=0;i<count;i++) particles.push(new Particle(x, y, color));
}
function createLevelUpFireworks() {
  const colors = ['#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff'];
  for(let i=0;i<5;i++){
    setTimeout(()=>{
      const x = Math.random()*(BOARD_WIDTH*BLOCK_SIZE);
      const y = Math.random()*(BOARD_HEIGHT*BLOCK_SIZE)*0.45;
      createFireworks(x, y, colors[Math.floor(Math.random()*colors.length)], 30);
    }, i*210);
  }
}
function updateParticles(){
  const ec = document.getElementById('effectsCanvas').getContext('2d');
  ec.clearRect(0,0,ec.canvas.width,ec.canvas.height);
  for(let i=particles.length-1;i>=0;i--){
    particles[i].update(); particles[i].draw(ec);
    if(particles[i].isDead()) particles.splice(i,1);
  }
}

// ========== 盤面初期化＆UI ==========

function initBoard() {
  board = [];
  for (let y=0; y<BOARD_HEIGHT; y++)
    board[y] = new Array(BOARD_WIDTH).fill(0);
}

// 新規ピース生成。現実のテトリス同様「出現場所ふさがってたら即終了」
function spawnNewPiece() {
  currentPiece = nextPiece || getRandomPiece();
  nextPiece = getRandomPiece();
  if (!canMove(currentPiece, 0, 0, currentPiece.shape)) {
    gameRunning = false;
    document.getElementById('gameOver').style.display = 'block';
    document.getElementById('finalScore').textContent = score;
    document.getElementById('finalLevel').textContent = level;
  }
}
function getRandomPiece() {
  const i = Math.floor(Math.random()*TETROMINOS.length);
  let shape = TETROMINOS[i].shape;
  // 横方向中央出現
  return {...TETROMINOS[i], x: Math.floor((BOARD_WIDTH-shape[0].length)/2), y: 0, shape: shape.map(r=>[...r])}
}
function canMove(piece, dx, dy, rotation=piece.shape) {
  for(let y=0; y<rotation.length; y++) for(let x=0; x<rotation[y].length; x++)
    if(rotation[y][x]){
      let nx = piece.x+x+dx, ny = piece.y+y+dy;
      if(nx<0||nx>=BOARD_WIDTH||ny>=BOARD_HEIGHT) return false;
      if(ny>=0 && board[ny][nx]) return false;
    }
  return true;
}
function placePiece(piece) {
  for(let y=0; y<piece.shape.length; y++)for(let x=0;x<piece.shape[y].length;x++)
    if(piece.shape[y][x]){
      let by = piece.y+y, bx = piece.x+x;
      if(by<0) continue;
      board[by][bx] = piece.color;
    }
}
// ========== 描画/UI ==========

function drawBlock(ctx, x, y, color){
  // 照明感強く
  let g = ctx.createLinearGradient(x, y, x+BLOCK_SIZE, y+BLOCK_SIZE);
  g.addColorStop(0.02, "#fff"); g.addColorStop(0.22, color); g.addColorStop(1, shadeColor(color,-40));
  ctx.fillStyle=g;
  ctx.fillRect(x,y,BLOCK_SIZE,BLOCK_SIZE);
  ctx.strokeStyle='#0af'; ctx.lineWidth=1;
  ctx.strokeRect(x+0.5,y+0.5,BLOCK_SIZE-1,BLOCK_SIZE-1);
}
function shadeColor(color, percent) {
  const f=parseInt(color.slice(1),16),t=percent<0?0:255,p=Math.abs(percent),
        R=f>>16, G=(f>>8)&0x00FF, B=f&0x0000FF;
  return "#"+(0x1000000+(Math.round((t-R)*p/100)+R)*0x10000
      +(Math.round((t-G)*p/100)+G)*0x100
      +(Math.round((t-B)*p/100)+B)).toString(16).slice(1);
}
function drawBoard() {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#131e35';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // 格子枠
  ctx.save();
  ctx.strokeStyle = '#22385c'; ctx.lineWidth = 1.2;
  for(let x=0;x<=BOARD_WIDTH;x++) ctx.beginPath(),ctx.moveTo(x*BLOCK_SIZE,0),ctx.lineTo(x*BLOCK_SIZE,canvas.height),ctx.stroke();
  for(let y=0;y<=BOARD_HEIGHT;y++) ctx.beginPath(),ctx.moveTo(0,y*BLOCK_SIZE),ctx.lineTo(canvas.width,y*BLOCK_SIZE),ctx.stroke();
  ctx.restore();
  // 本体
  for(let y=0;y<BOARD_HEIGHT;y++)
    for(let x=0;x<BOARD_WIDTH;x++)
      if(board[y][x]) drawBlock(ctx,x*BLOCK_SIZE,y*BLOCK_SIZE,board[y][x]);
  drawBoardFrame();
}
function drawPiece(piece) {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  for(let y=0;y<piece.shape.length;y++)
    for(let x=0;x<piece.shape[y].length;x++)
      if(piece.shape[y][x])
        drawBlock(ctx, (piece.x+x)*BLOCK_SIZE, (piece.y+y)*BLOCK_SIZE, piece.color);
}
function drawNextPiece() {
  nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  if(nextCtxMobile) nextCtxMobile.clearRect(0,0,nextCanvasMobile.width,nextCanvasMobile.height);
  if(nextPiece){
    // PC
    const offsetX = (nextCanvas.width-nextPiece.shape[0].length*15)/2;
    const offsetY = (nextCanvas.height-nextPiece.shape.length*15)/2;
    for(let y=0;y<nextPiece.shape.length;y++)
      for(let x=0;x<nextPiece.shape[y].length;x++)
        if(nextPiece.shape[y][x]){
          nextCtx.fillStyle=nextPiece.color;
          nextCtx.fillRect(offsetX+x*15, offsetY+y*15, 15,15);
          nextCtx.strokeStyle='#227';
          nextCtx.strokeRect(offsetX+x*15, offsetY+y*15, 15,15);
        }
    // モバイル
    if(nextCtxMobile){
      const mx = (nextCanvasMobile.width-nextPiece.shape[0].length*12)/2,
            my = (nextCanvasMobile.height-nextPiece.shape.length*12)/2;
      for(let y=0;y<nextPiece.shape.length;y++)
        for(let x=0;x<nextPiece.shape[y].length;x++)
          if(nextPiece.shape[y][x]){
            nextCtxMobile.fillStyle=nextPiece.color;
            nextCtxMobile.fillRect(mx+x*12, my+y*12, 12,12);
            nextCtxMobile.strokeStyle='#227';
            nextCtxMobile.strokeRect(mx+x*12, my+y*12, 12,12);
          }
    }
  }
}
function updateUI() {
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  document.getElementById('lines').textContent = lines;
  const ms=document.getElementById('mobileScore'),ml=document.getElementById('mobileLevel'),mls=document.getElementById('mobileLines');
  if(ms) ms.textContent=score; if(ml) ml.textContent=level; if(mls) mls.textContent=lines;
}

// ========== ゲーム進行 ==========

function clearLines() {
  let linesCleared = 0;
  for(let y=BOARD_HEIGHT-1; y>=0; y--) {
    if(board[y].every(cell=>cell!==0)) {
      for(let x=0;x<BOARD_WIDTH;x++)
        createFireworks((x+0.5)*BLOCK_SIZE,(y+0.5)*BLOCK_SIZE,board[y][x],12);
      board.splice(y,1); board.unshift(new Array(BOARD_WIDTH).fill(0));
      linesCleared++; y++;
    }
  }
  if(linesCleared>0){
    lines += linesCleared;
    const lineBonus=[0,40,100,300,1200];
    score += lineBonus[linesCleared]*level;
    let newLevel = Math.floor(lines/10)+1;
    if(newLevel>level){
      level=newLevel; dropInterval=Math.max(50,1000-(level-1)*50);
      createLevelUpFireworks();
    }
    updateUI();
  }
}
function rotatePiece(piece) {
  const rotated=[], N=piece.shape.length;
  for(let i=0;i<piece.shape[0].length;i++){
    rotated[i]=[]; for(let j=0;j<N;j++) rotated[i][j]=piece.shape[N-1-j][i];
  }
  return rotated;
}
// ======= メインループ =======
function gameLoop(currentTime){
  if(!gameRunning) return;
  updateParticles();
  if (currentPiece && currentTime-dropTime > dropInterval) {
    if (canMove(currentPiece,0,1)) {
      currentPiece.y++;
    } else {
      placePiece(currentPiece); clearLines();
      spawnNewPiece();
    }
    dropTime = currentTime;
  }
  drawBoard();
  if(currentPiece) drawPiece(currentPiece);
  requestAnimationFrame(gameLoop);
}
function startGame() {
  resizeCanvasForMobile();
  drawBoardFrame();
  initBoard(); score=0; level=1; lines=0; dropInterval=1000; gameRunning=true; particles=[];
  currentPiece = null; nextPiece = null;
  spawnNewPiece();
  updateUI(); drawNextPiece();
  document.getElementById('gameOver').style.display = 'none';
  requestAnimationFrame(gameLoop);
}

// ==== 操作入力 ====
function handleInput(key){
  if(!gameRunning||!currentPiece) return;
  switch(key){
    case 'ArrowLeft': case 'left': if(canMove(currentPiece,-1,0)) currentPiece.x--; break;
    case 'ArrowRight': case 'right': if(canMove(currentPiece,1,0)) currentPiece.x++; break;
    case 'ArrowDown': case 'down':
      if(canMove(currentPiece,0,1)){
        currentPiece.y++; score+=1; updateUI();
      } break;
    case 'ArrowUp': case 'rotate':
      const r = rotatePiece(currentPiece);
      if(canMove(currentPiece,0,0,r)) currentPiece.shape=r;
      break;
    case ' ': case 'drop':
      while(canMove(currentPiece,0,1)){currentPiece.y++;score+=2;}
      updateUI();
      break;
  }
}
// キーボード　操作
document.addEventListener('keydown', e=>{
  if(['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' '].includes(e.key))
    {handleInput(e.key);e.preventDefault();}
});

// タッチ＆クリック
["leftBtn","rightBtn","downBtn","rotateBtn","dropBtn"].forEach(id=>{
  const btn=document.getElementById(id);
  if(!btn) return;
  btn.addEventListener('touchstart', e=>{e.preventDefault();handleInput(btn.id.replace('Btn',''));});
  btn.addEventListener('click', ()=>handleInput(btn.id.replace('Btn','')));
});
let touchTimeout;
['leftBtn','rightBtn','downBtn'].forEach(id=>{
  const btn=document.getElementById(id);
  let isPressed=false;
  btn.addEventListener('touchstart',()=>{
    if(isPressed)return; isPressed=true;
    touchTimeout=setInterval(()=>{handleInput(id.replace('Btn',''));},130);
  });
  ['touchend','touchcancel'].forEach(type=>
    btn.addEventListener(type,()=>{isPressed=false;clearInterval(touchTimeout);}));
});

// ======= 最後に確実に起動 =======
startGame();
</script>
</body>
</html>
